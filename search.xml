<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的第一篇文章</title>
    <url>/2020/04/22/%E6%8E%8C%E6%8E%A7%E4%B9%A0%E6%83%AF%E9%98%85%E8%AF%BB%E5%8E%86%E7%A8%8B/</url>
    <content><![CDATA[<p>我是一个基本不看专业之外的书的人，阅读这本书应该说是一个意外。因为这次的疫情，我在住的地方非常的无聊，偶然间从网上看到了这本书，然后翻看了一下对这本书的评论，大多数评价也十分好，然后又去某乎上看看各位大佬的评价。各位大佬一顿吹嘘，我当时就有一种，这本书不看，你的人生是不完整的感觉。在抱着我的人生怎么可以不完整的想法下，下了一本PDF版的书。</p>
<p>开始看序章，又是一顿吹嘘，说的我晕头转向。还是不聊序章了，写这篇文章的时候我已经看这本书过一段时间了，现在再写这本书相关的东西，是不是有点晚。还是不纠结了，先写再说不是。</p>
<p>开始看正文，第一章，他告诉我微习惯的力量。说的是一个量变产生质变的问题。说每天改善一点，你的进步就会非常巨大。然后我的内心在说：这本书是不是忽悠人的，这个谁不知道到量变产生质变，但是至于用一章的内容去阐述这玩意么？</p>
<p>虽然看了第一章，有种被劝退的感觉，但是我也不是这么容易放弃的对么！于是我又坚持了一下下，看了第二章。看了一下开头，我的内心：哦，还不错的角度哦。它告诉我，改变习惯要先改变你的心态，适应你的身份，你之所以会有这些习惯和你的职业以及和你的身份相关，所以想要改变你的习惯，要适应你的身份，改变你的心里角色。看完之后，我的内心：牛皮！有点厉害啊。有点被吸引了，然后我按照它的方式写了一下我想成为的人，以及想做的事。</p>
<p>继续第三章！它讲了培养习惯的四步法：</p>
<ul>
<li>让他显而易见</li>
<li>让他有吸引力</li>
<li>让他简单易行</li>
<li>让他令人愉悦</li>
</ul>
<p>我的内心：嗯，难怪我以前一直尝试改变没有成功，看来原因很明显啊。卧槽不行，光看PDF是有问题的，我需要让看书变得简单易行和有吸引力。嗯，然后我就买了一个kindle。</p>
<p>后面就是一点一点的看书过程，我的内心也是各种“**”。这本书让我改变了很多，让我知道习惯如何去改变，以及如何去做到你想做的事。以及时刻的去调整你想要的改变的事。</p>
<p>如果有一天你想改变你自己的习惯，可以看一眼这本书。</p>
<p>我非常强力的推荐该书，推荐指数：五星</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>类继承</title>
    <url>/2020/04/23/%E7%B1%BB%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><p>注意点</p>
<p>1、对象名不会被看作地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//five是string对象</span></span><br><span class="line">five[<span class="number">6</span>]是一个<span class="keyword">char</span>类型的值</span><br><span class="line">所以&amp;five[<span class="number">6</span>]是一个地址</span><br></pre></td></tr></table></figure>

<p><code>string::npos</code> 表示<code>string</code> 对象可以存储的最大字符数。</p>
<h2 id="智能指针模板类"><a href="#智能指针模板类" class="headerlink" title="智能指针模板类"></a>智能指针模板类</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remodel</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	str = *ps;  <span class="comment">//这里调用的是赋值函数，而不是和c一样的地址赋值。</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>智能指针的作用是，在指针过期之后，指针指向的内存将被自动释放。</p>
<p>无法将指针转换为智能指针，因为智能指针的构造函数都是explicit</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">vacation</span><span class="params">(<span class="string">"hahah"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pvac</span><span class="params">(&amp;vacation)</span></span>;</span><br><span class="line"><span class="comment">/* 这个会引发错误，应为vacation是自动变量 在pvac过期时，会将delete用于非堆内存，这个会引发错误 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; films[<span class="number">5</span>] = &#123;</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"1"</span>)),</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"2"</span>)),</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"3"</span>)),</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"4"</span>)),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt;pwin;</span><br><span class="line">pwin = films[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//会将films[2]的所有权转让给pwin</span></span><br><span class="line"><span class="comment">//会导致films[2]无法引用该字符串</span></span><br><span class="line"><span class="comment">//当使用shared_ptr的时候则不会出现该问题</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt;pwin;</span><br><span class="line">pwin = films[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>使用<strong>shared_ptr</strong>的时候，这次pwin和films[2]指向同一个对象，而引用计数从1增加到2。在程序末尾，后声明的pwin首先调用其析构函数，该析构函数将引用计数降低到1。然后，shared_ptr数组的成员被释放，对filmsp[2]调用析构函数时，将引用计数降低到0，并释放以前分配的空间。</p>
<p><strong>unique_ptr</strong> :</p>
<p>当使用unique_ptr的时候，使用<code>pwin = films[2];</code> 该语句时，编译时就会出错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;pu3;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;pu4;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"yo"</span>));</span><br><span class="line">pu4 = demo(); <span class="comment">//demo返回一个对象</span></span><br><span class="line"><span class="comment">//unique_ptr允许临时对象赋值</span></span><br></pre></td></tr></table></figure>

<p><code>unique_ptr</code> 支持<code>delete[]</code> 和<code>new[]</code> 而<code>auto_ptr</code> 只支持<code>delete</code>和<code>new</code></p>
<p>另外STL容器不支持<code>unique_ptr</code> 有警告，和<code>auto_ptr</code> 行为不确定</p>
<h2 id="16-3标准模板库"><a href="#16-3标准模板库" class="headerlink" title="16.3标准模板库"></a>16.3标准模板库</h2><p>STL包含：容器、迭代器、函数、算法模板。</p>
<p>所有容器提供对矢量的操作包含</p>
<ol>
<li><code>size()</code> ：返回容器中的元素</li>
<li><code>swap()</code> ：交换两个容器的内容</li>
<li><code>begin()</code>：返回指向容器中第一个元素的迭代器</li>
<li><code>end()</code>：返回一个表示超过容器尾（past-the-end，指向容器最后一个元素后面的那个元素）的迭代器 </li>
</ol>
<p>迭代器的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">double</span>&gt;::iterator pd;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">double</span>&gt; score;</span><br><span class="line">pd = score.<span class="built_in">begin</span>();</span><br><span class="line">*pd = <span class="number">22.3</span>;</span><br><span class="line">++pd;</span><br><span class="line"><span class="keyword">auto</span> pd = score.<span class="built_in">begin</span>(); <span class="comment">//利用c++自动类型推断</span></span><br></pre></td></tr></table></figure>

<p><code>push_back()</code>：将元素添加到矢量末尾，无需了解长度</p>
<p><code>erase()</code>：删除矢量中给定区间的元素，接受两个迭代器参数，第一个迭代器指向区间的起始处，第二个迭代器位于区间终止处的后一个位置。</p>
<p><code>insert()</code>：插入元素，它接受3个迭代器参数，第一个参数指定了新元素的插入位置，第二个和第三个迭代器参数定义了被插入区间，该区间通常是另一个容器对象的一部分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">double</span>&gt; old_v;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">double</span>&gt; new_v;</span><br><span class="line">old.v.insert(old_v.<span class="built_in">begin</span>(),new_v.<span class="built_in">begin</span>()+<span class="number">1</span>, new_v.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//矢量new_v中除第一个元素外的所有元素插入到old_v矢量的第一个元素前面</span></span><br></pre></td></tr></table></figure>

<p><code>for_each()</code>函数：支持三个参数，前两个是定义容器中区间的迭代器，最后一个是指向函数的指针。</p>
<p>使用方式：<code>for_each(books.begin(), books.end(), showReview)</code>  <strong>被指向的函数不能修改容器元素的值</strong></p>
<p><code>Random_shuffle()</code> ：函数接受两个指定区间的迭代器参数，并随机排列该区间中的元素。<strong>该函数要求容器类允许随机访问。</strong>（for_each没有要求）</p>
<p><code>sort()</code> 也要求容器类允许随机访问。存在两个版本</p>
<p>版本一：要求提供可使用的 <code>&lt;</code> 操作符。操作默认使用 <code>&lt;</code> </p>
<p>版本二：如果想用其他的方式排序，有提供三个操作符的 <code>sort()</code>  前两个参数也是指定区间的迭代器，最后一个参数是指向要使用的函数的指针。</p>
<p><strong>基于范围的for循环（C++11）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">4.8</span>, <span class="number">4.3</span>, <span class="number">5.3</span>, <span class="number">7.6</span>, <span class="number">9.2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> x : prices)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : books) ShowReview();</span><br></pre></td></tr></table></figure>

<p>在这种 <code>for</code> 循环中，括号内的代码声明一个类型与容器存储的内容相同的变量，然后指出了容器的名称。接下来，循环体使用指定的变量依次访问容器的每个元素。</p>
<h2 id="16-4-泛型编程"><a href="#16-4-泛型编程" class="headerlink" title="16.4 泛型编程"></a>16.4 泛型编程</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnyType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(AnyType &amp;a, AnyType &amp;b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AnyType temp;</span><br><span class="line">	temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一行指出，要建立一个模板，并将类型命名为AnyType。关键字template和typename是必需的，除非可以使用关键字class代替typename。另外，必须使用尖括号。类型名可以任意选择（这里为AnyType），只要遵守C++命名规则即可；许多程序员都使用简单的名称，如T。</p>
<p>编译器只会根据模板创建需要的类型，而不是所有类型。</p>
<p>模板可以重载，但是函数的特征标志必须不一样（参数类型和数量）</p>
<p>模板具有很多局限性，例如：赋值操作符，比较操作符等。因此指定的模板智能用于特定的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非模板类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(job &amp;, job &amp;)</span></span>;</span><br><span class="line"><span class="comment">//模板类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;, T &amp;)</span></span>;</span><br><span class="line"><span class="comment">//显式具体化的原型，特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> Swap&lt;job&gt;(job &amp;, job &amp;);</span><br><span class="line"><span class="comment">//显式具体化也可以这样写</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(job &amp;, jon &amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果存在多个原型，编译器在进行选择是，非模板 &gt; 显式具体化 &gt; 模板版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显式实例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Add</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">10.5</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Add&lt;<span class="keyword">double</span>&gt;(x, m) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//显式实例化</span></span><br><span class="line"><span class="comment">//这里的模板与函数调用Add(x,m)不匹配，因为该模板要求两个函数参数的类型相同。但通过使用Add&lt;double&gt;(x,m)，可强制为double类型实例化，并将参数m强制转换为double类型，以便与函数Add&lt;double&gt;(double,double)的第二个参数匹配。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;, T &amp;)</span></span>; <span class="comment">//模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(job &amp;, job &amp;)</span></span>; <span class="comment">//显式具体化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> Swap&lt;<span class="keyword">char</span>&gt;(<span class="keyword">char</span> &amp;, <span class="keyword">char</span> &amp;); <span class="comment">//显式实例化</span></span><br></pre></td></tr></table></figure>

<p>注意点：当编译器看到显式实例化后，会使用模板来进行生成函数。其他版本则根据使用生成相应的版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">lesser</span><span class="params">(T a, T b)</span>  <span class="comment">//A</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lesser</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">//B</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">-30</span>;</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">12.2</span>;</span><br><span class="line"><span class="keyword">double</span> y = <span class="number">23.2</span>;</span><br><span class="line">lesser(m, n); <span class="comment">// 调用 B</span></span><br><span class="line">lesser(x, y); <span class="comment">// 调用 A</span></span><br><span class="line">lesser&lt;&gt;(m, n); <span class="comment">// 调用 A &lt;&gt;指明要用模板 </span></span><br><span class="line">lesser&lt;<span class="keyword">int</span>&gt;(x, y); <span class="comment">// 调用 A 也是指明用模板，但是是显式实例化，将模板实例化为int类型</span></span><br></pre></td></tr></table></figure>

<p><code>decltype</code>关键字 </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span> (x) y; <span class="comment">//将y的类型 设置为和x一样</span></span><br><span class="line"><span class="keyword">decltype</span>(x + y) xpy = x + y; <span class="comment">// 将xpy的类型设置为和x+y的返回值一样</span></span><br><span class="line">auto h(int x, float y) -&gt; double; //返回值类型后置</span><br><span class="line"><span class="comment">//可以这么用如下</span></span><br><span class="line">auto gt(T1 x, T2 y) -&gt; decltype(x + y);//当不知道x+y的返回值时可以这么声明函数</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>常见并发服务器设计</title>
    <url>/2020/04/23/%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="iterative服务器设计"><a href="#iterative服务器设计" class="headerlink" title="iterative服务器设计"></a>iterative服务器设计</h2><img src="https://i.loli.net/2020/04/25/kaU3OtmuLB4ZpPM.png" alt="image-20200315125728309" style="zoom:50%;" />

<p>每处理完一个请求就关闭连接，这个叫做短连接。循环式服务器，不能使用长连接。，单线程。decode，和computer以及encode处理时间不能太长。如果太长可能影响进程的响应时间。同时无法有效利用多核cpu。</p>
<h2 id="并发式服务器-concurrent服务器"><a href="#并发式服务器-concurrent服务器" class="headerlink" title="并发式服务器/concurrent服务器"></a>并发式服务器/concurrent服务器</h2><img src="https://i.loli.net/2020/04/25/XOkH6I31Z7pcah8.png" alt="image-20200315130103516" style="zoom:50%;" />

<h2 id="prefork-or-pre-htreaded-服务器设计"><a href="#prefork-or-pre-htreaded-服务器设计" class="headerlink" title="prefork or pre htreaded 服务器设计"></a>prefork or pre htreaded 服务器设计</h2><img src="https://i.loli.net/2020/04/25/VO2U6ivEleQLnT4.png" alt="image-20200315130331012" style="zoom:50%;" />

<p>这种服务器设置存在一个现象，多个进程都在等待，此时一个连接过来了，只有一个进程的accept可以正确返回，其他进程accept返回失败。这种现象叫做惊群。优势是可以减少创建进程的开销。</p>
<h2 id="反应式（reactive）服务器（reactor模式）"><a href="#反应式（reactive）服务器（reactor模式）" class="headerlink" title="反应式（reactive）服务器（reactor模式）"></a>反应式（reactive）服务器（reactor模式）</h2><p>select可以用来实现。并发处理多个请求，实际上是在一个线程中完成。无法充分利用多核cpu。</p>
<img src="https://i.loli.net/2020/04/25/KOxvzfcwhIRADJ8.png" alt="image-20200315133823235" style="zoom:50%;" />

<p>利用io多路复用实现（select/poll/epoll）,利用单线程轮询。</p>
<p>不适合执行时间比较长的服务，所以为了让客户感觉是在“并发”吗，处理而不是循环处理，每个请求必须在相对较短的时间内执行完成。</p>
<h2 id="reactor-thread-per-request（过渡方案）"><a href="#reactor-thread-per-request（过渡方案）" class="headerlink" title="reactor + thread per request（过渡方案）"></a>reactor + thread per request（过渡方案）</h2><h2 id="reactor-work-thread"><a href="#reactor-work-thread" class="headerlink" title="reactor + work thread"></a>reactor + work thread</h2><p>每个连接，在独立的线程中完成。不如并发式服务器。</p>
<h2 id="reactor-thread-pool"><a href="#reactor-thread-pool" class="headerlink" title="reactor + thread pool"></a>reactor + thread pool</h2><img src="C:/Users/liu_h/AppData/Roaming/Typora/typora-user-images/image-20200315134429851.png" alt="image-20200315134429851" style="zoom:50%;" />

<p>reactor是一个线程，读取请求包，将请求丢到线程池中处理，然后线程池会取出工作线程，进行处理。适应计算密集型任务（执行时间比较长的也可以适应）。线程池处理完之后，将数据包丢回reacrot 进行发送。</p>
<h2 id="multiple-reacrots（能适应更大的突发I-O）"><a href="#multiple-reacrots（能适应更大的突发I-O）" class="headerlink" title="multiple reacrots（能适应更大的突发I/O）"></a>multiple reacrots（能适应更大的突发I/O）</h2><img src="https://i.loli.net/2020/04/25/R6SzHyADXaiqTmd.png" alt="image-20200315134913187" style="zoom:50%;" />

<p>mainReactor负责acceptor，接收连接，然后交由subReactor进行监听，以及后续操作。该方式叫做round robing（轮叫）。使这些连接均匀的被分配。适应突发I/O。</p>
<p>使用场景：服务器有多个千兆网口，就是用多个subReactor。由千兆网卡的数量确定。</p>
<p>​     reactors in threads （one loop per thread）</p>
<p>​     reactors in process</p>
<h2 id="multiple-reactors-thread-pool（one-loop-pre-thread-threadpool）适应（突发I-O和密集计算）"><a href="#multiple-reactors-thread-pool（one-loop-pre-thread-threadpool）适应（突发I-O和密集计算）" class="headerlink" title="multiple reactors + thread pool（one loop pre thread + threadpool）适应（突发I/O和密集计算）"></a>multiple reactors + thread pool（one loop pre thread + threadpool）适应（突发I/O和密集计算）</h2><p>不能使用多进程实现，必须使用多线程。</p>
<img src="https://i.loli.net/2020/04/25/tdImeDCAjGJyqcU.png" alt="image-20200315135842620" style="zoom:50%;" />

<p>比较完美的方案。</p>
<p>可以有多个subReactor，但是threadpool只有一个，线程池是共享的。</p>
<h2 id="proactor服务器（protoactor模式，基于异步I-O）"><a href="#proactor服务器（protoactor模式，基于异步I-O）" class="headerlink" title="proactor服务器（protoactor模式，基于异步I/O）"></a>proactor服务器（protoactor模式，基于异步I/O）</h2><img src="https://i.loli.net/2020/04/25/z1r8VLROHeipwkq.png" alt="image-20200315142706483" style="zoom: 67%;" />

<h4 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h4><p>应用程序发送aio_read发送给内核，内核接收到之后执行initate read I/O操作，aio_read立刻返回，不需要等待initate read操作完成。</p>
<p>aio_read返回之后，应用就可以进行其他操作。</p>
<p>一旦内核空间的read操作完成之后，将数据从内核空间拷贝拷贝到用户空间，用户空间必须准备一块缓冲区接收数据，通过信号或者回调函数的方式通告应用程序，数据处理完成。</p>
<p>应用程序通过信号处理函数，或者回调函数响应内核中数据完成的事件。回调函数是在一个线程中执行。</p>
<p>信号处理函数和回调函数是在aio_read函数中指定的。通过异步I/O操作，I/O处理操作和其他操作重叠。</p>
<h4 id="同步I-O"><a href="#同步I-O" class="headerlink" title="同步I/O"></a>同步I/O</h4><p>之前的I/O操作依旧是同步I/O操作，只是指定的O_NONBLOCK标志。如果数据没有准备好，也是立即返回。</p>
<h4 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h4><p>仅仅只是得到通知，内核中有数据了，可以读取了，得到通知之后，数据还没处理完（数据还在内核缓冲区），依旧需要调用read将数据从内核缓冲区读取数据。异步I/O是在数据处理完成之后，内核直接采用推的方式，将数据从内核缓冲区中推送到用户空间。</p>
<p>理论上proactor比readctor效率要搞。</p>
<p>异步I/O能够让I/O操作与计算重叠，充分利用DMA特性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1.assets/LqVD7c3CNhYIa5T.png" alt="image-20200315144817170.png"></p>
<p>linux同时能启动多少个线程</p>
<p>对于32位的linux ，一个进程的地址空间是4G，其中用户态能访问3G左右，而一个线程的默认栈大小是10M，心算可知，一个进程大约最多能同时启动300个线程左右。</p>
<h4 id="多线程能提高并发度么？"><a href="#多线程能提高并发度么？" class="headerlink" title="多线程能提高并发度么？"></a>多线程能提高并发度么？</h4><p>1、如果之的是“并发连接数”，不能</p>
<p>2、如果单纯采用thread per connection的模型，name并发连接数大约300，这远远低于基于事件的单线程程序所能轻松达到的并发连接数（几千上万，甚至几万）。所谓“基于事件”，指的是用IO multiplexing event loop 的编程模型，又称reactor模式。</p>
<h4 id="多线程能提高吞吐量么？"><a href="#多线程能提高吞吐量么？" class="headerlink" title="多线程能提高吞吐量么？"></a>多线程能提高吞吐量么？</h4><p>3、对于计算密集型服务，不能</p>
<img src="https://i.loli.net/2020/04/25/eNq4GwztZTvPSQE.png" alt="image-20200315145524386" style="zoom:50%;" />

<h4 id="多线程能提高响应时间么"><a href="#多线程能提高响应时间么" class="headerlink" title="多线程能提高响应时间么"></a>多线程能提高响应时间么</h4><p>能。</p>
<h4 id="多线程如何让I-O和计算重叠"><a href="#多线程如何让I-O和计算重叠" class="headerlink" title="多线程如何让I/O和计算重叠"></a>多线程如何让I/O和计算重叠</h4><img src="https://i.loli.net/2020/04/25/23NjoZ85vwRqnOc.png" alt="image-20200315145843370" style="zoom:50%;" />

<h4 id="线程池大小的选择"><a href="#线程池大小的选择" class="headerlink" title="线程池大小的选择"></a>线程池大小的选择</h4><img src="https://i.loli.net/2020/04/25/GbBxRhQNp7YwuKZ.png" alt="image-20200315150029609" style="zoom:50%;" />

<h4 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h4><p>I/O线程</p>
<p>计算线程</p>
<p>第三方库，所用的线程</p>
]]></content>
      <tags>
        <tag>web服务器</tag>
      </tags>
  </entry>
</search>
